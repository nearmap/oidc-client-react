{"version":3,"sources":["../src/expiry-workaround.js"],"names":["document","userManager","onUserExpired","addEventListener","hidden","user","getUser","expired"],"mappings":"AAAA,SAAQA,QAAR,QAAuB,WAAvB;AAEA;;;;;;;;;;;;;AAYA,gBAAe,CAACC,WAAD,EAAcC,aAAd,KAA+B;AAC5CF,EAAAA,QAAQ,CAACG,gBAAT,CAA0B,kBAA1B,EAA8C,YAAW;AACvD;AACA,QAAIH,QAAQ,CAACI,MAAT,KAAoB,KAAxB,EAA+B;AAC7B;AACA;AACA,YAAMC,IAAI,GAAG,MAAMJ,WAAW,CAACK,OAAZ,EAAnB;;AAEA,UAAID,IAAI,IAAIA,IAAI,CAACE,OAAjB,EAA0B;AACxB;AACA;AACAL,QAAAA,aAAa;AACd;AACF;AACF,GAbD;AAcD,CAfD","sourcesContent":["import {document} from './globals';\n\n/*\n  The timer used by oidc-client for issuing a silent-renew does not work well\n  for when a computer wakes from sleep and the token has meanwhile expired or\n  is currently expiring.\n  See Point 7. at https://www.w3.org/TR/2011/WD-html5-20110525/timers.html#dom-windowtimers-settimeout\n\n  This means the refresh of a token does not happen in time and the application\n  does not get notified and will operate with an expired token.\n\n  To work around this we add an event listener on the document which gets\n  called whenever the user switches to the page/tab/window.\n */\nexport default (userManager, onUserExpired)=> {\n  document.addEventListener('visibilitychange', async ()=> {\n    // we only care when the user switches to the page.\n    if (document.hidden === false) {\n      // Getting the user will re-initialize all access-token events and the\n      // associate timers to implement expiry\n      const user = await userManager.getUser();\n\n      if (user && user.expired) {\n        // If the token has already expired, there won't be any new events\n        // coming from oidc-client, so we need to handle this manually.\n        onUserExpired();\n      }\n    }\n  });\n};\n"],"file":"expiry-workaround.js"}